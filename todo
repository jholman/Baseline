Tasks:
[✓] fundef tokenizer (rewrite existing one)
[✓] fundef parser
[✓] write super-retarded interpreter stub:
    [✓] initialize all data zones
        [ ] note: rstack format:
            [✓] your return location is a pair: fn-id, instruction-index
            [✓] these are pushed onto the rstack as two elements
            [✓] the inidx goes on first, then then fnid
            [✓] fn_id is negative if we're in inverse mode
    [✓] on program termination, spits out existing dstack, as a temporary measure
    [✓] read in function definitions into dictionary
    [✓] make 0 the default main
[✓] implement literal-push
[ ] implement some core functions
    [✓] pop, clone, move-to-bottom
    [✓] split, merge
    [✓] stdin-only variant of pipes_produce (needed for Hello World)
    [ ] the arithmetic functions
    [ ] flowcontrol: call, if-then, 
[✓] implement function calls from functions
[✓] write decorator to make stdlib-writing easier
[ ] flesh out the stdlib


Stuff I glossed over:
* proper handling of 0-register, in a LOT of places
    * a day later, I think : maybe this is under control now?
* unit-test development is way behind, now
* pipes code is totally non-general, of course
* my function nametable doesn't allow mixed baseline/python implementations, which was a goal







What commands get what function-ids?

stack commands
     1      pop
     2      clone
     3      move-to-bottom
     5      split
*    6      split-reverse
     7      merge
     8      swap-with-rstack
    
extra stack commands
    11      pop-n
    12      clone-n
    13      move-to-bottom-n
    
pipes
    21      produce
    22      consume
    23      open file
    24      open unix socket
    25      open TCP socket
    27      send UDP datagram
    29      sys.exit                    takes one int if avail, defaults to 0
    
flowcontrol
    30      call (unconditional)
    31      recurse call (to self)
    32      if-then
    33      if-then-else
    34      goto


arithmetic
    50      +
    51      -
    52      *
    53      /
    54      %
    55      ^
    56      log

binary arithmetic
    60      !
    61      &&
    62      ||
    63      wordwise xor

bitwise arithmetic
    71      bitwise not
    72      &
    73      |
    74      bitwise xor
    75      <<
    76      >>

comparisons
    81      <
    82      <=
    83      ==
    84      >=
    85      >
    86      !=





